/* Same as 56-2 but compute lower bounds for 'a' and 'b' in 'a^b'.

Initialize 'result' (e.g. to 0).
Start looping over decreasing a.

Check if current a can possibly have a power that gives a digit sum > result.
It can be checked this way:

  a^b = 10^k, where k is a rational.
  k = floor(b * ln(a) / ln(10)) + 1
  The max possible digit sum generated by a power of 'a' is 9*k.

If 9*k < result, we can exit the decreasing loop since next 'a' will yield a
lower value.

Get minimum for 'b' so that 'a^b' has enough digits to be > result.
It can be obtained this way:

  a^b = 10^k where k is a rational.
  k = floor(b * ln(a) / ln(10)) + 1
  k <= b * ln(a) / ln(10) + 2

We want 9*k > result, so we need to compute the digit sum only when

  b > (max/9 -2 ) * ln(10) / ln(a)
*/

package main

import (
	"fmt"
	"math"
	"math/big"
)

// This is too slow.
func digitsum(n *big.Int) int {
	sum := 0
	text, _ := n.MarshalText()
	for _, v := range text {
		sum += int(v - '0')
	}
	return sum
}

func max_digitsum(a, b int) int {
	a_float := float64(a)
	b_float := float64(b)
	return int(9 * (1 + math.Floor(b_float*math.Log10(a_float))))
}

func min_power(a, max int) int {
	a_float := float64(a)
	max_float := float64(max)

	return int((max_float/9 - 2) / math.Log10(a_float))
}

func main() {
	limit := 100
	result := 0

	for a := limit - 1; a >= 0; a-- {
		if result > max_digitsum(a, limit-1) {
			fmt.Println(result)
			return
		}
		a_big := big.NewInt(int64(a))
		mul := big.NewInt(0)

		min := min_power(a, result)
		bigMin := big.NewInt(int64(min - 1))

		mul.Exp(a_big, bigMin, nil)

		for b := min; b <= limit-1; b++ {
			mul.Mul(mul, a_big)
			sum := digitsum(mul)
			if sum > result {
				result = sum
			}
		}
	}

}
