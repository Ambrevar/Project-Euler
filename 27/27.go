/* Quadratic formula: Qab(n) = n^2 + a*n + b

Qab(0) = b, so b must be prime to generate at least one prime.
Qab(1) = 1 + a + b, so a must be odd to generate at least 2 primes.

When n==b or n==b-a, Qab(n) is not prime. Thus we can stop looping when b or b-a
are positive and less than best result so far.

Since b>2, the highest value comes with n=996, a=999, b=997, thus
Qab(n) < 2000000. This is useful to bound the sieve.
*/
package main

import "fmt"

// See problem 3.
func make_sieve(limit uint) (sieve []bool) {
	var bound uint
	if limit > 1 {
		bound = limit * limit
	} else if limit == 1 {
		bound = 2
	} else {
		bound = 1
	}

	sieve = make([]bool, bound)
	sieve[0] = true
	if limit == 0 {
		return
	}
	sieve[1] = true
	for i := uint(2); i <= limit; i++ {
		if !sieve[i] {
			for j := i * i; j < bound; j += i {
				sieve[j] = true
			}
		}
	}

	return
}

var sieve []bool

// Number of primes generated by the quadratic expression.
func quadprime(a, b int) int {
	n := 0
	for q := n*n + a*n + b; q >= 0 && !sieve[q]; q = n*n + a*n + b {
		n++
	}
	return n
}

func main() {
	// Generate a sieve of 2000000 primes.
	sieve = make_sieve(1415)

	maxprimes := 0
	maxa := 0
	maxb := 0
	for b := 997; b > maxprimes; b-- {
		if sieve[b] {
			continue
		}
		for a := -999; a <= -1; a += 2 {
			res := quadprime(a, b)
			if res > maxprimes {
				maxprimes = res
				maxa = a
				maxb = b
			}
		}
		for a := 1; a < b && b-a > maxprimes; a += 2 {
			res := quadprime(a, b)
			if res > maxprimes {
				maxprimes = res
				maxa = a
				maxb = b
			}
		}
		for a := b; a < 1000; a += 2 {
			res := quadprime(a, b)
			if res > maxprimes {
				maxprimes = res
				maxa = a
				maxb = b
			}
		}
	}

	fmt.Println(maxa * maxb)
}
